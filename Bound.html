<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Bound</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Bound.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Bound.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">bound-0.9.1: Making de Bruijn Succ Less</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>Edward Kmett &lt;ekmett@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Bound</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Manipulating user terms
</a></li><li><a href="#g:2">Scopes introduce bound variables
</a><ul><li><a href="#g:3">Abstraction over bound variables
</a></li><li><a href="#g:4">Instantiation of bound variables
</a></li></ul></li><li><a href="#g:5">Structures permitting substitution
</a></li><li><a href="#g:6">Conversion to Traditional de Bruijn
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>We represent the target language itself as an ideal monad supplied by the
 user, and provide a <code><a href="Bound.html#t:Scope">Scope</a></code> monad transformer for introducing bound
 variables in user supplied terms. Users supply a <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a></code> and <code>Traversable</code>
 instance, and we traverse to find free variables, and use the <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a></code> to
 perform substitution that avoids bound variables.
</p><p>An untyped lambda calculus:
</p><pre>
 {-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
 import Bound
 import Control.Applicative
 import Control.Monad (<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:ap">ap</a></code>)
 import Prelude.Extras
 import Data.Foldable
 import Data.Traversable
</pre><pre>
 infixl 9 :@
 data Exp a = V a | Exp a :@ Exp a | Lam (<code><a href="Bound.html#t:Scope">Scope</a></code> () Exp a)
   deriving (<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a></code>,<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a></code>,<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a></code>,<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a></code>,<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a></code>,<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a></code>,<code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Traversable">Traversable</a></code>)
</pre><pre>
 instance <code><a href="Prelude-Extras.html#t:Eq1">Eq1</a></code> Exp
 instance <code><a href="Prelude-Extras.html#t:Ord1">Ord1</a></code> Exp
 instance <code><a href="Prelude-Extras.html#t:Show1">Show1</a></code> Exp
 instance <code><a href="Prelude-Extras.html#t:Read1">Read1</a></code> Exp
 instance <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code> Exp where <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Applicative.html#t:pure">pure</a></code> = V; (<code>&lt;*&gt;</code>) = <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:ap">ap</a></code>
</pre><pre>
 instance <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a></code> Exp where
   <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:return">return</a></code> = V
   V a      <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> f = f a
   (x :@ y) <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> f = (x <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> f) :@ (y &gt;&gt;= f)
   Lam e    <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> f = Lam (e <code><a href="Bound.html#v:-62--62--62--61-">&gt;&gt;&gt;=</a></code> f)
</pre><pre>
 lam :: <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a></code> a =&gt; a -&gt; <code>Exp</code> a -&gt; <code>Exp</code> a
 lam v b = Lam (<code><a href="Bound.html#v:abstract1">abstract1</a></code> v b)
</pre><pre>
 whnf :: <code>Exp</code> a -&gt; <code>Exp</code> a
 whnf (f :@ a) = case whnf f of
   Lam b -&gt; whnf (<code><a href="Bound.html#v:instantiate1">instantiate1</a></code> a b)
   f'    -&gt; f' :@ a
 whnf e = e
</pre><p>More exotic combinators for manipulating a <code><a href="Bound.html#t:Scope">Scope</a></code> can be imported from
 <a href="Bound-Scope.html">Bound.Scope</a>.
</p><p>You can also retain names in your bound variables by using <code><a href="Bound-Name.html#t:Name">Name</a></code>
 and the related combinators from <a href="Bound-Name.html">Bound.Name</a>. They are not re-exported
 from this module by default.
</p><p>The approach used in this package was first elaborated upon by Richard Bird 
 and Ross Patterson
 in &quot;de Bruijn notation as a nested data type&quot;, available from
 <a href="http://www.cs.uwyo.edu/~jlc/courses/5000_fall_08/debruijn_as_nested_datatype.pdf">http://www.cs.uwyo.edu/~jlc/courses/5000_fall_08/debruijn_as_nested_datatype.pdf</a>
</p><p>However, the combinators they used required higher rank types. Here we
 demonstrate that the higher rank <code>gfold</code> combinator they used isn't necessary
 to build the monad and use a monad transformer to encapsulate the novel
 recursion pattern in their generalized de Bruijn representation. It is named
 <code><a href="Bound.html#t:Scope">Scope</a></code> to match up with the terminology and usage pattern from Conor McBride
 and James McKinna's &quot;I am not a number: I am a free variable&quot;, available
 from <a href="http://www.cs.st-andrews.ac.uk/~james/RESEARCH/notanum.pdf">http://www.cs.st-andrews.ac.uk/~james/RESEARCH/notanum.pdf</a>, but since
 the set of variables is visible in the type, we can provide stronger type
 safety guarantees.
</p><p>There are longer examples in the <code>examples/</code> folder:
</p><p><a href="https://github.com/ekmett/bound/tree/master/examples">https://github.com/ekmett/bound/tree/master/examples</a>
</p><ol><li> <em>Simple.hs</em> provides an untyped lambda calculus with recursive let
   bindings and includes an evaluator for the untyped lambda calculus and a
   longer example taken from Lennart Augustsson's <a href="&#955;-calculus cooked four   ways.html">&#955;-calculus cooked four   ways</a> available from <a href="http://www.augustsson.net/Darcs/Lambda/top.pdf">http://www.augustsson.net/Darcs/Lambda/top.pdf</a>
</li><li> <em>Derived.hs</em> shows how much of the API can be automated with
    DeriveTraversable and adds combinators for building binders that support
    pattern matching.
</li><li> <em>Overkill.hs</em> provides very strongly typed pattern matching many modern
   language extensions, including polymorphic kinds to ensure type safety.
   In general, the approach taken by Derived seems to deliver a better power
   to weight ratio.
</li></ol></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:substitute">substitute</a> :: (<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a) =&gt; a -&gt; f a -&gt; f a -&gt; f a</li><li class="src short"><a href="#v:isClosed">isClosed</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> f =&gt; f a -&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:closed">closed</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Traversable.html#t:Traversable">Traversable</a> f =&gt; f a -&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> (f b)</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:Scope">Scope</a> b f a = <a href="#v:Scope">Scope</a> {<ul class="subs"><li><a href="#v:unscope">unscope</a> :: f (<a href="Bound.html#t:Var">Var</a> b (f a))</li></ul>}</li><li class="src short"><a href="#v:abstract">abstract</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; (a -&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b) -&gt; f a -&gt; <a href="Bound.html#t:Scope">Scope</a> b f a</li><li class="src short"><a href="#v:abstract1">abstract1</a> :: (<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a) =&gt; a -&gt; f a -&gt; <a href="Bound.html#t:Scope">Scope</a> () f a</li><li class="src short"><a href="#v:instantiate">instantiate</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; (b -&gt; f a) -&gt; <a href="Bound.html#t:Scope">Scope</a> b f a -&gt; f a</li><li class="src short"><a href="#v:instantiate1">instantiate1</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; f a -&gt; <a href="Bound.html#t:Scope">Scope</a> n f a -&gt; f a</li><li class="src short"><span class="keyword">class</span>  <a href="#t:Bound">Bound</a> t  <span class="keyword">where</span><ul class="subs"><li><a href="#v:-62--62--62--61-">(&gt;&gt;&gt;=)</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; t f a -&gt; (a -&gt; f c) -&gt; t f c</li></ul></li><li class="src short"><a href="#v:-61--60--60--60-">(=&lt;&lt;&lt;)</a> :: (<a href="Bound.html#t:Bound">Bound</a> t, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f) =&gt; (a -&gt; f c) -&gt; t f a -&gt; t f c</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Var">Var</a> b a<ul class="subs"><li>= <a href="#v:B">B</a> b  </li><li>| <a href="#v:F">F</a> a  </li></ul></li><li class="src short"><a href="#v:fromScope">fromScope</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; <a href="Bound.html#t:Scope">Scope</a> b f a -&gt; f (<a href="Bound.html#t:Var">Var</a> b a)</li><li class="src short"><a href="#v:toScope">toScope</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; f (<a href="Bound.html#t:Var">Var</a> b a) -&gt; <a href="Bound.html#t:Scope">Scope</a> b f a</li></ul></div><div id="interface"><h1 id="g:1">Manipulating user terms
</h1><div class="top"><p class="src"><a name="v:substitute" class="def">substitute</a> :: (<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a) =&gt; a -&gt; f a -&gt; f a -&gt; f a<a href="src/Bound-Term.html#substitute" class="link">Source</a></p><div class="doc"><p><code><code><a href="Bound.html#v:substitute">substitute</a></code> a p w</code> replaces the free variable <code>a</code> with <code>p</code> in <code>w</code>.
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>substitute &quot;hello&quot; [&quot;goodnight&quot;,&quot;Gracie&quot;] [&quot;hello&quot;,&quot;!!!&quot;]
</code></strong>[&quot;goodnight&quot;,&quot;Gracie&quot;,&quot;!!!&quot;]
</pre></div></div><div class="top"><p class="src"><a name="v:isClosed" class="def">isClosed</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> f =&gt; f a -&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a><a href="src/Bound-Term.html#isClosed" class="link">Source</a></p><div class="doc"><p>A closed term has no free variables.
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isClosed []
</code></strong>True
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isClosed [1,2,3]
</code></strong>False
</pre></div></div><div class="top"><p class="src"><a name="v:closed" class="def">closed</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Traversable.html#t:Traversable">Traversable</a> f =&gt; f a -&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> (f b)<a href="src/Bound-Term.html#closed" class="link">Source</a></p><div class="doc"><p>If a term has no free variables, you can freely change the type of
 free variables it is parameterized on.
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>closed [12]
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>closed &quot;&quot;
</code></strong>Just []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t closed &quot;&quot;
</code></strong>closed &quot;&quot; :: Maybe [b]
</pre></div></div><h1 id="g:2">Scopes introduce bound variables
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:Scope" class="def">Scope</a> b f a <a href="src/Bound-Scope.html#Scope" class="link">Source</a></p><div class="doc"><p><code><code><a href="Bound.html#t:Scope">Scope</a></code> b f a</code> is an <code>f</code> expression with bound variables in <code>b</code>,
 and free variables in <code>a</code>
</p><p>We store bound variables as their generalized de Bruijn
 representation in that we're allowed to <code>lift</code> (using <code><a href="Bound.html#v:F">F</a></code>) an entire
 tree rather than only succ individual variables, but we're still
 only allowed to do so once per <code><a href="Bound.html#t:Scope">Scope</a></code>. Weakening trees permits
 <em>O(1)</em> weakening and permits more sharing opportunities. Here the
 deBruijn 0 is represented by the <code><a href="Bound.html#v:B">B</a></code> constructor of <code><a href="Bound.html#t:Var">Var</a></code>, while the
 de Bruijn <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:succ">succ</a></code> (which may be applied to an entire tree!) is handled
 by <code><a href="Bound.html#v:F">F</a></code>.
</p><p>NB: equality and comparison quotient out the distinct <code><a href="Bound.html#v:F">F</a></code> placements
 allowed by the generalized de Bruijn representation and return the
 same result as a traditional de Bruijn representation would.
</p><p>Logically you can think of this as if the shape were the traditional
 <code>f (Var b a)</code>, but the extra <code>f a</code> inside permits us a cheaper <code>lift</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Scope" class="def">Scope</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:unscope" class="def">unscope</a> :: f (<a href="Bound.html#t:Var">Var</a> b (f a))</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Scope" class="caption collapser" onclick="toggleSection('i:Scope')">Instances</p><div id="section.i:Scope" class="show"><table><tr><td class="src">MonadTrans (<a href="Bound.html#t:Scope">Scope</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Bound.html#t:Bound">Bound</a> (<a href="Bound.html#t:Scope">Scope</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc"><p>The monad permits substitution on free variables, while preserving
 bound variables
</p></td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> f =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> f =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc"><p><code><code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#v:toList">toList</a></code></code> is provides a list (with duplicates) of the free variables
</p></td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Traversable.html#t:Traversable">Traversable</a> f =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Traversable.html#t:Traversable">Traversable</a> (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Hashable b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, Hashable1 f) =&gt; Hashable1 (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Serial b, Serial1 f) =&gt; Serial1 (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> b, Show1 f) =&gt; Show1 (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> b, Read1 f) =&gt; Read1 (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> b, Ord1 f) =&gt; Ord1 (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> b, Eq1 f) =&gt; Eq1 (<a href="Bound.html#t:Scope">Scope</a> b f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> b, Eq1 f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> b, Ord1 f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> b, Read1 f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> b, Show1 f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Hashable b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, Hashable1 f, Hashable a) =&gt; Hashable (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Binary b, Serial1 f, Binary a) =&gt; Binary (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Serial b, Serial1 f, Serial a) =&gt; Serial (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Serialize b, Serial1 f, Serialize a) =&gt; Serialize (<a href="Bound.html#t:Scope">Scope</a> b f a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:3">Abstraction over bound variables
</h2><div class="top"><p class="src"><a name="v:abstract" class="def">abstract</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; (a -&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b) -&gt; f a -&gt; <a href="Bound.html#t:Scope">Scope</a> b f a<a href="src/Bound-Scope.html#abstract" class="link">Source</a></p><div class="doc"><p>Capture some free variables in an expression to yield
 a <code><a href="Bound.html#t:Scope">Scope</a></code> with bound variables in <code>b</code>
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:m + Data.List
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>abstract (`elemIndex` &quot;bar&quot;) &quot;barry&quot;
</code></strong>Scope [B 0,B 1,B 2,B 2,F &quot;y&quot;]
</pre></div></div><div class="top"><p class="src"><a name="v:abstract1" class="def">abstract1</a> :: (<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a) =&gt; a -&gt; f a -&gt; <a href="Bound.html#t:Scope">Scope</a> () f a<a href="src/Bound-Scope.html#abstract1" class="link">Source</a></p><div class="doc"><p>Abstract over a single variable
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>abstract1 'x' &quot;xyz&quot;
</code></strong>Scope [B (),F &quot;y&quot;,F &quot;z&quot;]
</pre></div></div><h2 id="g:4">Instantiation of bound variables
</h2><div class="top"><p class="src"><a name="v:instantiate" class="def">instantiate</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; (b -&gt; f a) -&gt; <a href="Bound.html#t:Scope">Scope</a> b f a -&gt; f a<a href="src/Bound-Scope.html#instantiate" class="link">Source</a></p><div class="doc"><p>Enter a scope, instantiating all bound variables
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:m + Data.List
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instantiate (\x -&gt; [toEnum (97 + x)]) $ abstract (`elemIndex` &quot;bar&quot;) &quot;barry&quot;
</code></strong>&quot;abccy&quot;
</pre></div></div><div class="top"><p class="src"><a name="v:instantiate1" class="def">instantiate1</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; f a -&gt; <a href="Bound.html#t:Scope">Scope</a> n f a -&gt; f a<a href="src/Bound-Scope.html#instantiate1" class="link">Source</a></p><div class="doc"><p>Enter a <code><a href="Bound.html#t:Scope">Scope</a></code> that binds one variable, instantiating it
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instantiate1 &quot;x&quot; $ Scope [B (),F &quot;y&quot;,F &quot;z&quot;]
</code></strong>&quot;xyz&quot;
</pre></div></div><h1 id="g:5">Structures permitting substitution
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Bound" class="def">Bound</a> t  <span class="keyword">where</span><a href="src/Bound-Class.html#Bound" class="link">Source</a></p><div class="doc"><p>Instances of <code><a href="Bound.html#t:Bound">Bound</a></code> generate left modules over monads.
</p><p>This means they should satisfy the following laws:
</p><pre> m &gt;&gt;&gt;= return &#8801; m
 m &gt;&gt;&gt;= (&#955; x &#8594; k x &gt;&gt;= h) &#8801; (m &gt;&gt;&gt;= k) &gt;&gt;&gt;= </pre><p>This guarantees that a typical Monad instance for an expression type
 where Bound instances appear will satisfy the Monad laws (see doc/BoundLaws.hs).
</p><p>If instances of Bound are monad transformers, then <code>m <code><a href="Bound.html#v:-62--62--62--61-">&gt;&gt;&gt;=</a></code> f &#8801; m <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> <code>lift</code> <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:.">.</a></code> f</code>
 implies the above laws, and is in fact the default definition.
</p><p>This is useful for types like expression lists, case alternatives,
 schemas, etc. that may not be expressions in their own right, but often
 contain expressions.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:-62--62--62--61-" class="def">(&gt;&gt;&gt;=)</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; t f a -&gt; (a -&gt; f c) -&gt; t f c<a href="src/Bound-Class.html#%3E%3E%3E%3D" class="link">Source</a></p><div class="doc"><p>Perform substitution
</p><p>If <code>t</code> is an instance of <code>MonadTrans</code> and you are compiling on GHC &gt;= 7.4, then this
 gets the default definition:
</p><pre>m <code><a href="Bound.html#v:-62--62--62--61-">&gt;&gt;&gt;=</a></code> f = m <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> <code>lift</code> <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:.">.</a></code> f</pre></div></div><div class="subs instances"><p id="control.i:Bound" class="caption collapser" onclick="toggleSection('i:Bound')">Instances</p><div id="section.i:Bound" class="show"><table><tr><td class="src"><a href="Bound.html#t:Bound">Bound</a> (<a href="Bound.html#t:Scope">Scope</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Bound.html#t:Bound">Bound</a> (<a href="Bound-Scope-Simple.html#t:Scope">Scope</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:-61--60--60--60-" class="def">(=&lt;&lt;&lt;)</a> :: (<a href="Bound.html#t:Bound">Bound</a> t, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f) =&gt; (a -&gt; f c) -&gt; t f a -&gt; t f c<a href="src/Bound-Class.html#%3D%3C%3C%3C" class="link">Source</a></p><div class="doc"><p>A flipped version of (<code><a href="Bound.html#v:-62--62--62--61-">&gt;&gt;&gt;=</a></code>).
</p><pre>(<code><a href="Bound.html#v:-61--60--60--60-">=&lt;&lt;&lt;</a></code>) = <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:flip">flip</a></code> (<code><a href="Bound.html#v:-62--62--62--61-">&gt;&gt;&gt;=</a></code>)</pre></div></div><h1 id="g:6">Conversion to Traditional de Bruijn
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Var" class="def">Var</a> b a <a href="src/Bound-Var.html#Var" class="link">Source</a></p><div class="doc"><p>&quot;I am not a number, I am a <em>free monad</em>!&quot;
</p><p>A <code><code><a href="Bound.html#t:Var">Var</a></code> b a</code> is a variable that may either be &quot;bound&quot; (<code><a href="Bound.html#v:B">B</a></code>) or &quot;free&quot; (<code><a href="Bound.html#v:F">F</a></code>).
</p><p>(It is also technically a free monad in the same near-trivial sense as
 <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Either.html#t:Either">Either</a></code>.)
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:B" class="def">B</a> b</td><td class="doc"><p>this is a bound variable
</p></td></tr><tr><td class="src"><a name="v:F" class="def">F</a> a</td><td class="doc"><p>this is a free variable
</p></td></tr></table></div><div class="subs instances"><p id="control.i:Var" class="caption collapser" onclick="toggleSection('i:Var')">Instances</p><div id="section.i:Var" class="show"><table><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Typeable-Internal.html#t:Typeable2">Typeable2</a> <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Bifunctor <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Hashable2 <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Bifoldable <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Bitraversable <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Serial2 <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show2 <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Read2 <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Ord2 <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Eq2 <a href="Bound.html#t:Var">Var</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Traversable.html#t:Traversable">Traversable</a> (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Hashable b =&gt; Hashable1 (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Serial b =&gt; Serial1 (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> b =&gt; Show1 (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> b =&gt; Read1 (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> b =&gt; Ord1 (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> b =&gt; Eq1 (<a href="Bound.html#t:Var">Var</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Data.html#t:Data">Data</a> b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Data.html#t:Data">Data</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Data.html#t:Data">Data</a> (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Ord.html#t:Ord">Ord</a> (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Read.html#t:Read">Read</a> (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> b, <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/GHC-Generics.html#t:Generic">Generic</a> (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Hashable b, Hashable a) =&gt; Hashable (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Binary b, Binary a) =&gt; Binary (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Serial b, Serial a) =&gt; Serial (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Serialize b, Serialize a) =&gt; Serialize (<a href="Bound.html#t:Var">Var</a> b a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:fromScope" class="def">fromScope</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; <a href="Bound.html#t:Scope">Scope</a> b f a -&gt; f (<a href="Bound.html#t:Var">Var</a> b a)<a href="src/Bound-Scope.html#fromScope" class="link">Source</a></p><div class="doc"><p><code><code><a href="Bound.html#v:fromScope">fromScope</a></code></code> quotients out the possible placements of <code><a href="Bound.html#v:F">F</a></code> in <code><a href="Bound.html#t:Scope">Scope</a></code>
 by distributing them all to the leaves. This yields a more traditional
 de Bruijn indexing scheme for bound variables.
</p><p>Since,
</p><pre><code><a href="Bound.html#v:fromScope">fromScope</a></code> <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:.">.</a></code> <code><a href="Bound.html#v:toScope">toScope</a></code> &#8801; <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:id">id</a></code></pre><p>we know that
</p><pre><code><a href="Bound.html#v:fromScope">fromScope</a></code> <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:.">.</a></code> <code><a href="Bound.html#v:toScope">toScope</a></code> <code><a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#v:.">.</a></code> <code><a href="Bound.html#v:fromScope">fromScope</a></code> &#8801; <code><a href="Bound.html#v:fromScope">fromScope</a></code></pre><p>and therefore <code>(<code><a href="Bound.html#v:toScope">toScope</a></code> . <code><a href="Bound.html#v:fromScope">fromScope</a></code>)</code> is idempotent.
</p></div></div><div class="top"><p class="src"><a name="v:toScope" class="def">toScope</a> :: <a href="/usr/local/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> f =&gt; f (<a href="Bound.html#t:Var">Var</a> b a) -&gt; <a href="Bound.html#t:Scope">Scope</a> b f a<a href="src/Bound-Scope.html#toScope" class="link">Source</a></p><div class="doc"><p>Convert from traditional de Bruijn to generalized de Bruijn indices.
</p><p>This requires a full tree traversal
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>